# Using the MCP3551

**WARNING: incompatibility with the board! NC (pin1) and CS(pin2) of the PMOD MCP board must be swapped.**

* The *design* subdirectory provides an example for routing the #SPI0# signals through the FPGA.
* The *app* subdirectory provides the ``dts`` file for activating drivers and dependencies and an 
application that sequentially performs an acquisition on each ADC and displays it in column form.

## Connections

The Red Pitaya Light board provides 4 dedicated PMOD connectors for adding ADC boards. The following 
tables reference the pins used for communication.

* The first three PMOD are connected to the SPI0 controller of the Zynq CPU (PS) through the FPGA, which
requires loading a design into the FPGA to perform the routing.
* The last one (PMOD4) is directly connected to the SPI1 controller through the pins of the PS section.

A design containing the routing is available in the *design* directory. By correctly filling in the 
variables and having ``vivado`` in the ``PATH``, running a ``make`` command will generate the corresponding 
bitstream.

### PMOD1, PMOD2, PMOD3

| PIN Redpitaya |   PIN Zynq   | Pmod1 | Pmod2 | Pmod3 |
|---------------|--------------|-------|-------|-------|
| E1 Pin1       |              |  VCC  |  VCC  |  VCC  |
| E1 Pin26      |              |  GND  |  GND  |       |
| E1 Pin5       | K16/PL_DIO6P |  SCK  |  SCK  |  SCK  |
| E1 Pin4       | L14/PL_DIO4P |  SDO  |  SDO  |  SDO  |
| E1 Pin6       | K18/PL_DIOXY |  CS#  |       |       |
| E1 Pin6       | J16/PL_DIOXY |       |  CS#  |       |
| E1 Pin6       | K17/PL_DIOXY |       |       |  CS#  |

### PMOD4
| PIN Redpitaya |          PIN Zynq         | Pmod4 |
|---------------|---------------------------|-------|
| E1 Pin1       |                           |  VCC  |
| E1 Pin26      |                           |  GND  |
| E2 Pin5       | SPI(SCK)  D9/PS_MIO12_500 |  SCK  |
| E2 Pin4       | SPI(MISO) C6/PS_MIO11_500 |  SDO  |
| E2 Pin6       | SPI(CS#)  E8/PS_MIO13_500 |  CS#  |

## Modification of the Red Pitaya system

The default configuration of the Linux kernel, provided by Buildroot, for the Red Pitaya does not 
include support for the MCP3551. Therefore, it must be enabled manually.

To do this, go to the root of the Buildroot configured for the Red Pitaya and:

1. Run ``make linux-menuconfig`` to configure the Linux kernel (and not Buildroot itself!)
2. ``Device Drivers -> Industrial I/O support -> Analog to digital converters -> <*> Microchip Technology MCP3x01/02/04/08 and MCP3550/1/3``
3. Exit with ESC and EXIT
4. Run ``make linux-rebuild``
5. Transfer the file ``output/images/zImage`` to ``/boot`` of the Red Pitaya or copy to the SD card first partition. (This can be done 
by inserting the SD card into the computer or via SSH: ``scp output/images/zImage root@192.168.0.10:/boot`` or whatever the IP of the
Red Pitaya is)

To apply the kernel modification, the board **must** be rebooted.

## Creating a devicetree overlay to enable support

By default, the two SPI controllers of the Red Pitaya are not activated, and the use of devices on 
an SPI bus requires adding them as sub-nodes of the corresponding controller. The simplest solution 
is to use a *devicetree overlay*, which modifies and/or adds nodes in the default configuration tree 
of the board (the code below is a copy of the file ``app/redSPI.dts``)

The corresponding ``.dts`` file is available in ``app.`` and the ``dtbo`` generated from compiling this 
file will be generated by ``make``.

```
/dts-v1/;
/plugin/;

/ {
    compatible = "xlnx,zynq-7000";
    
    fragment0 {
        target = <&fpga_full>;
        __overlay__ {
            firmware-name = "redSPI_wrapper.bit.bin";
        };
    };

    fragment1 {
        target-path = "/";
        __overlay__ {
            #address-cells = <1>;
            /* #size-cells = <0>; incompatibility issue ?! */
            reg_mcp: vref-reg@0 {
                compatible ="regulator-fixed";
                reg = <1>;
                regulator-name = "vref-reg";
                regulator-min-microvolt = <3300000>;
                regulator-max-microvolt = <3300000>;
            };
        };
    };

    /* PMOD1, PMOD2, PMOD3 */
    fragment2 {
        target = <&spi0>;
        __overlay__ {
            #address-cells = <1>;
            #size-cells = <0>;
            status = "okay";
            num-cs = <3>;
            is-decoded-cs = <0>;
            pmod1: pmod1@0 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <0>;
            };

            pmod2: pmod2@1 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <1>;
            };

            pmod3: pmod3@2 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <2>;
            };
        };
    };

    /* PMOD4 */
    fragment3 {
        target = <&spi1>;
        __overlay__ {
            #address-cells = <1>;
            #size-cells = <0>;
            status = "okay";
            num-cs = <1>;
            is-decoded-cs = <0>;
            pmod4: pmod4@0 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <0>;
            };
        };
    };
};

```
is compiled with:
```bash
${BR_DIR}/output/host/usr/bin/dtc -@ -I dts -O dtb -o LeFichier.dtbo LeFichier.dts
```

and loaded using 
```bash
mkdir /sys/kernel/config/device-tree/overlays/mcp
cat mcp-of.dtbo > /sys/kernel/config/device-tree/overlays/mcp/dtbo
```

The various files in the *app* directiry automate these tasks with
``make`` and ``make install``

## Usage

**Warning: slaves (between PMOD1 and PMOD3) are not activated in the right order!**
* pmod1 matches device3
* pmod2 matches device2
* pmod2 matches device1
* pmod4 matches device4


Two approches:
### Manually
```bash
cd /sys/bus/iio/devices/iio:deviceX/
```
with X between 1 and 4

Get the scale factor (bit/uV ratio)
```bash
cat in_voltage-voltage_scale
```
Get the current value
```bash
cat in_voltage0-voltage1_raw
```
The final result is obtained by multiplying one with the other.

### code C

A full example is found in the *app* directory. It is compiled with ``make``
and installed in the shared NFS directory with ``make install``

```C
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

int main()
{
    int value, ret;
    double scale;

    /* obtention du scale */
    FILE *fd = fopen("/sys/bus/iio/devices/iio:device1/in_voltage-voltage_scale", "r");
    if (!fd) {
        printf("error opening\n");
        return 1;
    }
    fscanf(fd, "%lf", &scale); // convert character strings
    printf("%10.24lf\n", scale);
    fclose(fd);

    /* open data file */
    fd = fopen("/sys/bus/iio/devices/iio:device1/in_voltage0-voltage1_raw", "r");
    if (!fd) {
        printf("error opening\n");
        return 1;
    }
    while (1) {
        // again convert
        fscanf(fd, "%d", &value);
        printf("%d %3.12lf\n", value, (double)value*scale);
        /* VERY IMPORTANT:
         * "rewind" the file after each read otherwise always
         * the same value is returned
         */
        fseek(fd, 0, SEEK_SET);
        ret = usleep(100*1000);
        if (ret != 0) {
            printf("usleep error %s\n", strerror(ret));
            return 1;
        }

    }

    return 0;
}
```

# Utilisation du MCP3551 (French version)

**ATTENTION: incompatibilité avec la carte d'accueil! Il faut croiser NC (pin1)
et CS(pin2) de la carte PMOD MCP**

* Le sous-répertoire *design* propose un exemple pour router les signaux de *SPI0* au travers du FPGA
* le sous-répertoire *app* propose le dts pour l'activation de tout ce qui est
  nécessaire et une application qui réalise séquentiellement une acquisition sur
  chaque ADC et l'affiche sous forme de colonnes.

## Connexions

La carte redpitaya light propose 4 connecteurs PMOD dédiés à l'ajout
des cartes ADC. Les tableaux suivant référencent les broches utilisées pour la communication.

* les trois premiers connecteurs PMOD sont reliés au contrôleur SPI0 du CPU (PS)
du zynq au travers du FPGA (ceci nécessite un design à charger dans le FPGA pour
réaliser le routage);
* le dernier (PMOD4) est directement relié au
contrôleur SPI1 par les broches de la partie PS.

Un design contenant le routage est disponible dans *design*, ex&eacute;cuter ``make``
avec les variables correctement remplies et *vivado* dans le *PATH* permet de générer le *bitstream*
correspondant.

### PMOD1, PMOD2, PMOD3

| PIN Redpitaya |   PIN Zynq   | Pmod1 | Pmod2 | Pmod3 |
|---------------|--------------|-------|-------|-------|
| E1 Pin1       |              |  VCC  |  VCC  |  VCC  |
| E1 Pin26      |              |  GND  |  GND  |       |
| E1 Pin5       | K16/PL_DIO6P |  SCK  |  SCK  |  SCK  |
| E1 Pin4       | L14/PL_DIO4P |  SDO  |  SDO  |  SDO  |
| E1 Pin6       | K18/PL_DIOXY |  CS#  |       |       |
| E1 Pin6       | J16/PL_DIOXY |       |  CS#  |       |
| E1 Pin6       | K17/PL_DIOXY |       |       |  CS#  |

### PMOD4
| PIN Redpitaya |          PIN Zynq         | Pmod4 |
|---------------|---------------------------|-------|
| E1 Pin1       |                           |  VCC  |
| E1 Pin26      |                           |  GND  |
| E2 Pin5       | SPI(SCK)  D9/PS_MIO12_500 |  SCK  |
| E2 Pin4       | SPI(MISO) C6/PS_MIO11_500 |  SDO  |
| E2 Pin6       | SPI(CS#)  E8/PS_MIO13_500 |  CS#  |

## Modification du système de la redpitaya

La configuration par défaut du noyau linux, fournie par *buildroot*, pour la *redpitaya*
ne contient pas de support pour le *MCP3551*. Il est donc nécessaire de l'activer
manuellement.

Pour cela, se placer à la racine du buildroot destiné à la redpitaya et:

1. *make linux-menuconfig*
2. Devices Drivers -> Industrial I/O support -> Analog to digital converters ->
   <\*> Microchip Technology MCP3x01/02/04/08 and MCP3550/1/3
3. sortir (ESC et EXIT)
4. *make linux-rebuild*
5. envoyer le fichier *output/images/zImage* dans */boot* de la redpitaya. (Ceci
   peut se faire en insérant la carte SD dans son ordinateur ou par ssh:
   `scp output/images/zImage root@192.168.0.10:/boot`

Pour que la modification du noyau soit prise en compte il faut
**impérativement** redémarrer la carte (si copie par SSH).

## Création du devicetree overlay pour activer le support


Par défaut les deux contrôleurs SPI de la *redpitaya* ne sont pas activés, et
l'utilisation de périphériques sur un bus SPI nécessite que ceux-ci soient
ajoutés code *sous-noeuds* du controleur correspondant. La solution la plus
simple est d'utiliser un *devicetree overlay* qui a pour fonction de modifier
et/ou ajouter des noeuds dans l'arbre de configuration, par défaut, de la carte
(le code ci-dessous est une copie du fichier *app/redSPI.dts*)

Le fichier *.dts* correspondant est disponible dans *app*, le dtbo issus de la
compilation de ce fichier sera généré par `make`.


```
/dts-v1/;
/plugin/;

/ {
    compatible = "xlnx,zynq-7000";
    
    fragment0 {
        target = <&fpga_full>;
        __overlay__ {
            firmware-name = "redSPI_wrapper.bit.bin";
        };
    };

    fragment1 {
        target-path = "/";
        __overlay__ {
            #address-cells = <1>;
            /* #size-cells = <0>; incompatibility issue ?! */
            reg_mcp: vref-reg@0 {
                compatible ="regulator-fixed";
                reg = <1>;
                regulator-name = "vref-reg";
                regulator-min-microvolt = <5000000>;
                regulator-max-microvolt = <5000000>;
            };
        };
    };

    /* PMOD1, PMOD2, PMOD3 */
    fragment2 {
        target = <&spi0>;
        __overlay__ {
            #address-cells = <1>;
            #size-cells = <0>;
            status = "okay";
            num-cs = <3>;
            is-decoded-cs = <0>;
            pmod1: pmod1@0 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <0>;
            };

            pmod2: pmod2@1 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <1>;
            };

            pmod3: pmod3@2 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <2>;
            };
        };
    };

    /* PMOD4 */
    fragment3 {
        target = <&spi1>;
        __overlay__ {
            #address-cells = <1>;
            #size-cells = <0>;
            status = "okay";
            num-cs = <1>;
            is-decoded-cs = <0>;
            pmod4: pmod4@0 {
                compatible = "microchip,mcp3551";
                vref-supply = <&reg_mcp>;
                spi-max-frequency = <1000000>;
                reg = <0>;
            };
        };
    };
};

```
compilation classique par:
```bash
${BR_DIR}/output/host/usr/bin/dtc -@ -I dts -O dtb -o LeFichier.dtbo LeFichier.dts
```

chargement également classique par
```bash
mkdir /sys/kernel/config/device-tree/overlays/mcp
cat mcp-of.dtbo > /sys/kernel/config/device-tree/overlays/mcp/dtbo
```

Les divers fichiers dans le répertoire *app* proposent la même chose mais
automatiquement par ```make``` et ```make install```

## Utilisation

**Attention: les esclaves (entre PMOD1 et PMOD3) ne sont pas activés dans le bon ordre!**
* pmod1 correspond a device3
* pmod2 correspond a device2
* pmod2 correspond a device1
* pmod4 correspond a device4


Deux approches :
### A la main
```bash
cd /sys/bus/iio/devices/iio:deviceX/
```
Avec X entre 1 et 4

Obtention du scale (rapport bit/uV)
```bash
cat in_voltage-voltage_scale
```
Obtention de la valeur courante
```bash
cat in_voltage0-voltage1_raw
```
Ne reste plus qu'à multiplier l'un par l'autre

### code C

Un exemple complet est proposé dans le répertoire *app*. Il sera compilé par
`make` et installé dans un répertoire partagé en *NFS* par `make install`

```C
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

int main()
{
    int value, ret;
    double scale;

    /* obtention du scale */
    FILE *fd = fopen("/sys/bus/iio/devices/iio:device1/in_voltage-voltage_scale", "r");
    if (!fd) {
        printf("erreur d'ouverture\n");
        return 1;
    }
    fscanf(fd, "%lf", &scale); // ce sont des chaines de caracteres, faut
                               // convertir
    printf("%10.24lf\n", scale);
    fclose(fd);

    /* ouverture du fichier de valeur */
    fd = fopen("/sys/bus/iio/devices/iio:device1/in_voltage0-voltage1_raw", "r");
    if (!fd) {
        printf("erreur d'ouverture\n");
        return 1;
    }
    while (1) {
        // idem conversion necessaire
        fscanf(fd, "%d", &value);
        printf("%d %3.12lf\n", value, (double)value*scale);
        /* TRES IMPORTANT:
         * il faut "rembobiner" le fichier apres chaque lecture
         * sinon c'est toujours la même qui est fournie
         */
        fseek(fd, 0, SEEK_SET);
        ret = usleep(100*1000);
        if (ret != 0) {
            printf("erreur de usleep %s\n", strerror(ret));
            return 1;
        }

    }

    return 0;
}
```
